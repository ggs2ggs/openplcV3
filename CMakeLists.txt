# Copyright 2019 Smarter Grid Solutions
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http ://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissionsand
# limitations under the License.

cmake_minimum_required(VERSION 3.0.0)

# CMake build for OpenPLC runtime.

# Currently, this CMake file only builds the unit tests for the application - this is
# not currently used for building the actual runtime  on the system.

project(openplc_program)

# If we are building libmodbus, we treat it as an external project
# so include that capability for cmake
include(ExternalProject)

# Include settings that are specific to a particular target environment
include(${PROJECT_SOURCE_DIR}/cmake/settings.cmake)

option(WERROR "Set all warnings to errors" ON)

# Enable building the application with different set of capabilties
# depending on the capabilities that we want.
option(OPLC_ALL "Build all optional capabilities" ON)
option(OPLC_DNP3_OUTSTATION "Enable the DNP3 outstation" OFF)
option(OPLC_MODBUS "Enable the Modbus" OFF)
option(OPLC_NOOP_APP "Enable building a demo app" OFF)
option(OPLC_UNITTEST "Enable unit tests" OFF)

# These options enable building libraries containing the various harware layers.
# The objective of these builds is to ensure that the code compiles cleanly.
option(OPLC_BLANK_LIB "Enable buidling the default blank library" OFF)
option(OPLC_NEURON_LIB "Enable buidling the default Neuron library" OFF)
option(OPLC_PIXTEND_LIB "Enable buidling the default Pixtend library" OFF)
option(OPLC_PIXTEND2L_LIB "Enable buidling the default Pixtend2l library" OFF)
option(OPLC_PIXTEND2S_LIB "Enable buidling the default Pixtend2l library" OFF)
option(OPLC_RASPERBERRYPI_LIB "Enable buidling the default RaspberryPI library" OFF)
option(OPLC_RASPERBERRYPIOLD_LIB "Enable buidling the default RaspberryPI OLD library" OFF)
option(OPLC_SIMULINK_LIB "Enable buidling the default Simulink library" OFF)
option(OPLC_UNIPI_LIB "Enable buidling the default Unipi library" OFF)
option(OPLC_FISCHERTECHNIK_LIB "Enable buidling the default fischertechnik library" OFF)

if(OPLC_ALL)
  message("Enabling all optional components")
  set(OPLC_DNP3_OUTSTATION ON)
  set(OPLC_MODBUS ON)
  set(OPLC_NOOP_APP ON)
  set(OPLC_UNITTEST ON)

  set(OPLC_BLANK_LIB ON)
  set(OPLC_NEURON_LIB ON)
  set(OPLC_PIXTEND_LIB ON)
  set(OPLC_PIXTEND2L_LIB ON)
  set(OPLC_PIXTEND2S_LIB ON)
  set(OPLC_RASPERBERRYPI_LIB ON)
  set(OPLC_RASPERBERRYPIOLD_LIB ON)
  set(OPLC_SIMULINK_LIB ON)
  set(OPLC_UNIPI_LIB ON)
  set(OPLC_FISCHERTECHNIK_LIB ON)
endif()

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)

# If we have enabled the DNP3 outstation, then build opendnp3. Opendnp3 is
# CMake based, so we can just add that as a subdirectory and everything will
# work nicely.
if(OPLC_DNP3_OUTSTATION)
    add_subdirectory(utils/dnp3_src bin/dnp3)
    include_directories(utils/dnp3_src/cpp/libs/include)
endif()

# If we have enabled the Modbus, then build Modbus. Modbus is
# Makefile based
if(OPLC_MODBUS)
	# This whole modbus thing isn't nice, but it is how the project has
	# libmodbus directly included and I don't want to change that now
  include_directories(utils/libmodbus_src/src)
	ExternalProject_Add(libmodbus_proj
		SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/utils/libmodbus_src
		BUILD_IN_SOURCE 1
		CONFIGURE_COMMAND ./autogen.sh COMMAND ./configure  --prefix=${CMAKE_CURRENT_SOURCE_DIR}/utils/libmodbus_src/install
		BUILD_COMMAND ${MAKE})

	set(LIBMODBUS_INSTALL_DIR ${CMAKE_CURRENT_SOURCE_DIR}/utils/libmodbus_src/install)
	include_directories(${LIBMODBUS_INSTALL_DIR}/include)
	link_directories(${LIBMODBUS_INSTALL_DIR}/lib)
endif()

include_directories(runtime/vendor/spdlog-1.3.1)
include_directories(runtime/vendor/catch2-2.7.0)
include_directories(runtime/vendor/fakeit-2.0.5)
include_directories(runtime/core)
include_directories(runtime/core/lib)

# The OpenPLC core files
file(GLOB oplc_SRC runtime/core/dnp3_publisher.cpp runtime/core/dnp3_receiver.cpp runtime/core/dnp3.cpp)

# In order to build an OPLC application, we need code generated by the glue
# generator for a minimal system. In order to ensure that everything builds
# nicely, we have a empty application that does nothing, but ensures that
# all the right symbols are defined. From this, we can ensure that everything
# builds nicely together.
if (OPLC_NOOP_APP)
	file(GLOB oplcnoop_SRC runtime/example/*.cpp)
	add_executable(oplcnoop ${oplc_SRC} runtime/example/noop.cpp runtime/hardware_layers/blank.cpp runtime/core/main.cpp runtime/core/interactive_server.cpp runtime/core/server.cpp runtime/core/modbus.cpp runtime/core/modbus_master.cpp runtime/example/Config0.cpp)
	add_dependencies(oplcnoop libmodbus_proj)
	target_link_libraries(oplcnoop LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Unit tests for the OpenPLC runtime.
if(OPLC_UNITTEST)
	file(GLOB oplctest_SRC runtime/test/*.cpp)
	add_executable(oplctest ${oplctest_SRC} runtime/core/dnp3_publisher.cpp runtime/core/dnp3_receiver.cpp)
	target_link_libraries(oplctest LINK_PUBLIC asiodnp3 ${OPLC_PTHREAD})
endif()

# Default application built for blank (Linux)
if(OPLC_BLANK_LIB)
	add_library(oplcblank ${oplc_SRC} runtime/hardware_layers/blank.cpp)
	target_link_libraries(oplcblank LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for Neuron
if(OPLC_NEURON_LIB)
	add_library(oplcneuron ${oplc_SRC} runtime/hardware_layers/neuron.cpp)
	target_link_libraries(oplcneuron LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for Pixtend
if(OPLC_PIXTEND_LIB)
	add_library(oplcpixtend ${oplc_SRC} runtime/hardware_layers/pixtend.cpp)
	target_include_directories(oplcpixtend SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcpixtend LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for Pixtend2L
if(OPLC_PIXTEND2L_LIB)
	add_library(oplcpixtend2l ${oplc_SRC} runtime/hardware_layers/pixtend2l.cpp)
	target_include_directories(oplcpixtend2l SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcpixtend2l LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()


# Default application built for Pixtend2S
if(OPLC_PIXTEND2S_LIB)
	add_library(oplcpixtend2s ${oplc_SRC} runtime/hardware_layers/pixtend2s.cpp)
	target_include_directories(oplcpixtend2s SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcpixtend2s LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for RaspberryPI
if(OPLC_RASPERBERRYPI_LIB)
	add_library(oplcraspberrypi ${oplc_SRC} runtime/hardware_layers/raspberrypi.cpp)
	target_include_directories(oplcraspberrypi SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcraspberrypi LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for RaspberryPI (Old)
if(OPLC_RASPERBERRYPIOLD_LIB)
	add_library(oplcraspberrypiold ${oplc_SRC} runtime/hardware_layers/raspberrypi_old.cpp)
	target_include_directories(oplcraspberrypiold SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcraspberrypiold LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for Simulink
if(OPLC_SIMULINK_LIB)
	add_library(oplcsimulink ${oplc_SRC} runtime/hardware_layers/simulink.cpp)
	target_include_directories(oplcsimulink SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcsimulink LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for UniPI
if(OPLC_UNIPI_LIB)
	add_library(oplcunipi ${oplc_SRC} runtime/hardware_layers/unipi.cpp)
	target_include_directories(oplcunipi SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcunipi LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()

# Default application built for Fischertechnik 
if(OPLC_FISCHERTECHNIK_LIB)
	add_library(oplcfischertechnik ${oplc_SRC} runtime/hardware_layers/fischertechnik.cpp)
	target_include_directories(oplcfischertechnik SYSTEM PUBLIC runtime/test/mock_headers)
	target_link_libraries(oplcfischertechnik LINK_PUBLIC asiodnp3 libmodbus.so ${OPLC_PTHREAD})
endif()
